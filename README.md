# 第一章 可复用面向对象软件设计思想
#
## 1 为什么需要面向对象设计模式
+ 不是所有“设计模式”都是“面向对象设计模式”，在其他领域也有设计模式
### 面向对象的思想
+ 底层思维：向下，把握好机器底层，从微观理解面向对象构造
	+ 语言构造
	+ 编译转换
	+ 内存模型
	+ 运行时机制
    + 面向对象的三大对象机制
		+ 封装，隐藏内部实现
		+ 继承，复用现有代码
		+ 多态，改写对象行为 
+ 抽象思维：向上，如何将现实世界的事物抽象成代码
	+ 面向对象
	+ 组件封装
	+ 设计模式
	+ 架构模式
+ 代码是面向对象的，不代表思想也是面向对象的
### 软件领域的复杂性根本原因：变化
+ 客户需求变化
+ 技术平台变化
+ 开发团队变化
+ 市场环境变化
### 如何解决复杂性
+ 分解
	+ 分而治之，解决多个子问题的方式解决整个大问题
	+ 面向过程，结构化设计
+ 抽象
	+ 由于不能掌握全部的复杂对象，忽视非本质的细节，处理泛化和理想化对象模型 
### 好的软件设计应该有极高的复用性
+ 抽象的设计方法就是将多个属于同一抽象类的问题统一处理
	+ 统一的处理方法方法只对于统一的抽象类，处理方法不变，抽象类不变，变的只是继承抽象类的子类
## 2 面向对象八个设计原则
+ 复用的天敌是变化，面向对象的设计原则就是抵御变化
	+ 隔离变化：将变化带来的影响范围减为最小
	+ 各负其责：强调各个类的“责任”，需求变化带来的新增类的实现不应该影响原来类型的实现
		+ 运用多态，接口一样，实现不一样，大家都干这个事，但是你怎么干和我怎么干不一样
### 以文件夹VS中的shap_old.cpp和shap_new.cpp为例
### 依赖倒置原则（DIP）
+ 高层模块（稳定）不应该依赖于低层模块（变化),二者都应依赖于抽象（稳定）
	+ MainFrom是高层模块，如果它依赖于Line和Rect（低层模块）就是不稳定的，依赖于shap（抽象）就是稳定的
+ 抽象（稳定）不应该依赖于实现细节（变化），实现细节应该依赖于抽象（稳定） 
+ 
+ 通过抽象类隔离变化
### 开放封闭原则（OCP）
+ 对扩展开放，对更改封闭
+ 类模块应该是可扩展，但是不可修改的
+  
+ 用扩展去应对需求而不是满大街修改
### 单一职责原则（SRP）
+ 一个类应该仅有一个引起变化的原因。
+ 变化的方向隐含着类的职责
+  
+ 不要把类写的很臃肿，一个类应该只有一个责任 
### Liskvo替换原则（LSP）
+ 子类必须能够替换它们的基类（IS-A）
+ 继承表达类的抽象
+ 
+ 所有需要父类的地方子类都可以传过去使用
### 接口隔离原则（ISP）
+ 不应该强迫客户程序依赖他们不用的方法
+ 接口应该小而完备
+ 
+ 不需要public出去的成员就不要public，接口越少，和客户程序（即使用接口的程序）产生的依赖就越少
### 优先使用对象组合，而不是类继承
+ 类继承通常为“白箱复用”，对象组合通常为“黑箱复用”
+ 继承某种程度上破坏了封装性，子类父类耦合度高
+ 对象组合只要求被组合对象有良好的接口，耦合度低
+ 
+ 面向对象不是继承，不是有继承才叫面向对象，不应误用继承
+ 父类给子类暴露的东西很多，破坏了封装性 
### 封装变化点 
+ 使用封装来创建对象之间的分界层，让设计者可以在分界层的一侧进行修改，而不会对另一侧产生不良影响，从而实现层次间的松耦合
+ 
+ 封装不是为了封装代码和数据，是为了封装变化点
### 针对接口编程，而不是针对实现编程
+ 不将变量类型声明为某个特定的类型，而是声明为某个接口
	+ 例如MainForm里声明的是接口类shap而不是特定的Line和Rect
	+ 对于有些特定场合，还是需要声明具体类型的
+ 客户程序无需获知对象的具体类型，只需知道对所具有的的接口
	+ 例如MainForm里只知道shap里的的Draw()不知道是Line的Draw还是Rect的Draw
+ 减少系统中各部分的依赖关系，从而实现“高聚合，松耦合”的类型设计方案 



###
+ 设计模式不仅限于这些常用设计模式，也可以实现自己的设计模式
+ 设计模式都是由这八个设计原则推导出来的，所有设计模式必须遵循，如果违背，就不是好的设计模式